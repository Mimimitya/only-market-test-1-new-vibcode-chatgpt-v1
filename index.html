/**
 * OnlyMarket backend (single-file demo)
 * - Auth + sessions
 * - Wallet (balances, topup invoices, withdrawals)
 * - Deals with escrow-like flow
 * - Chat per deal
 * - Audit logs (for user + admin)
 * - Admin: users (ban/role), adjust balance, view user logs + user deals, global logs
 *
 * UI: onlymarket_dark.html (same dir)
 *
 * Run:
 *   npm i express cookie-parser
 *   node server.dark.js
 */

const fs = require("fs");
const path = require("path");
const crypto = require("crypto");
const express = require("express");
const cookieParser = require("cookie-parser");

const PORT = process.env.PORT ? Number(process.env.PORT) : 3000;
const HOST = process.env.HOST || "0.0.0.0";

const FILE_HTML = path.join(__dirname, "onlymarket_dark.html");
const DATA_DIR = path.join(__dirname, "data");

const SESSION_COOKIE = "om_session";
const SESSION_TTL_MS = 1000 * 60 * 60 * 24 * 14; // 14 days

// Payment providers config (internal mapping; UI doesn't expose providers)
const CRYPTOBOT_PAY_BASE = process.env.CRYPTOBOT_PAY_BASE || "https://t.me/CryptoBot";
const PLATEGA_PAY_BASE = process.env.PLATEGA_PAY_BASE || "https://example.com/pay";

if (!fs.existsSync(DATA_DIR)) fs.mkdirSync(DATA_DIR, { recursive: true });

function readJson(file, fallback) {
  try {
    const p = path.join(DATA_DIR, file);
    if (!fs.existsSync(p)) return fallback;
    const raw = fs.readFileSync(p, "utf-8");
    if (!raw.trim()) return fallback;
    return JSON.parse(raw);
  } catch (e) {
    console.error("readJson failed:", file, e);
    return fallback;
  }
}
function writeJson(file, data) {
  const p = path.join(DATA_DIR, file);
  const tmp = p + ".tmp";
  fs.writeFileSync(tmp, JSON.stringify(data, null, 2));
  fs.renameSync(tmp, p);
}
function now() { return Date.now(); }
function rid(prefix) { return prefix + "_" + crypto.randomBytes(9).toString("hex"); }
function clampStr(s, max = 180) {
  const x = String(s ?? "");
  return x.length > max ? x.slice(0, max) + "â€¦" : x;
}
function round2(x) { return Math.round(Number(x) * 100) / 100; }

// ---------- password hashing ----------
function scryptHash(password, salt) {
  return new Promise((resolve, reject) => {
    crypto.scrypt(password, salt, 64, { N: 16384, r: 8, p: 1 }, (err, derivedKey) => {
      if (err) return reject(err);
      resolve(derivedKey.toString("hex"));
    });
  });
}
async function hashPassword(password) {
  const salt = crypto.randomBytes(16).toString("hex");
  const hash = await scryptHash(password, salt);
  return { salt, hash };
}
async function verifyPassword(password, stored) {
  if (!stored || !stored.salt || !stored.hash) return false;
  const hash = await scryptHash(password, stored.salt);
  const a = Buffer.from(hash, "hex");
  const b = Buffer.from(stored.hash, "hex");
  if (a.length !== b.length) return false;
  return crypto.timingSafeEqual(a, b);
}

// ---------- state ----------
let db = {
  users: readJson("users.json", []),
  sessions: readJson("sessions.json", {}),
  balances: readJson("balances.json", {}),
  topups: readJson("topups.json", {}),
  withdrawals: readJson("withdrawals.json", {}),
  deals: readJson("deals.json", {}), // id -> deal
  dealMessages: readJson("deal_messages.json", {}), // dealId -> [messages]
  audit: readJson("audit.json", [])
};

function persist() {
  writeJson("users.json", db.users);
  writeJson("sessions.json", db.sessions);
  writeJson("balances.json", db.balances);
  writeJson("topups.json", db.topups);
  writeJson("withdrawals.json", db.withdrawals);
  writeJson("deals.json", db.deals);
  writeJson("deal_messages.json", db.dealMessages);
  writeJson("audit.json", db.audit);
}

function getUserById(id) { return db.users.find(u => u.id === id); }
function getUserByEmail(email) { return db.users.find(u => u.email.toLowerCase() === String(email).toLowerCase()); }
function getUserByUsername(username) { return db.users.find(u => u.username.toLowerCase() === String(username).toLowerCase()); }

function safeUser(u) {
  return { id: u.id, email: u.email, username: u.username, role: u.role, isBanned: !!u.isBanned, createdAt: u.createdAt };
}

function ensureBalance(userId) {
  if (!db.balances[userId]) db.balances[userId] = { USD: 0, EUR: 0, RUB: 0 };
  for (const k of ["USD", "EUR", "RUB"]) {
    if (typeof db.balances[userId][k] !== "number" || !Number.isFinite(db.balances[userId][k])) db.balances[userId][k] = 0;
  }
  return db.balances[userId];
}

function audit({ type, summary, actorId, targetUserId, req, meta }) {
  const entry = {
    id: rid("log"),
    ts: now(),
    type,
    summary: clampStr(summary || ""),
    actorId: actorId || null,
    targetUserId: targetUserId || null,
    ip: req ? (req.headers["x-forwarded-for"] || req.socket.remoteAddress || "").toString().split(",")[0].trim() : null,
    ua: req ? String(req.headers["user-agent"] || "") : null,
    meta: meta || {}
  };
  db.audit.push(entry);
  const MAX = 30000;
  if (db.audit.length > MAX) db.audit = db.audit.slice(db.audit.length - MAX);
  persist();
  return entry;
}

// ---------- bootstrap demo admin if empty ----------
async function bootstrapDemoAdmin() {
  if (db.users.length) return;
  const email = "admin@onlymarket.local";
  const username = "admin";
  const password = "admin12345";

  const pw = await hashPassword(password);
  const user = { id: rid("u"), email, username, password: pw, role: "admin", isBanned: false, createdAt: now() };
  db.users.push(user);
  ensureBalance(user.id);

  audit({ type: "auth.bootstrap_admin", summary: "Created demo admin (first run)", actorId: user.id, targetUserId: user.id, req: null, meta: { email } });
  persist();

  console.log("============================================================");
  console.log("DEMO ADMIN CREATED (first run):");
  console.log("  email:", email);
  console.log("  password:", password);
  console.log("CHANGE THIS IN PRODUCTION.");
  console.log("============================================================");
}

// ---------- auth middleware ----------
function getSession(req) {
  const token = req.cookies[SESSION_COOKIE];
  if (!token) return null;
  const s = db.sessions[token];
  if (!s) return null;
  if (s.expiresAt < now()) {
    delete db.sessions[token];
    persist();
    return null;
  }
  return { token, ...s };
}
function requireAuth(req, res, next) {
  const s = getSession(req);
  if (!s) return res.status(401).json({ error: "Not authenticated" });
  const user = getUserById(s.userId);
  if (!user) return res.status(401).json({ error: "Session invalid" });
  if (user.isBanned) return res.status(403).json({ error: "User banned" });
  req.user = user;
  req.session = s;
  next();
}
function requireAdmin(req, res, next) {
  if (!req.user || req.user.role !== "admin") return res.status(403).json({ error: "Admin only" });
  next();
}
function setSessionCookie(res, token) {
  res.cookie(SESSION_COOKIE, token, {
    httpOnly: true,
    sameSite: "lax",
    secure: false, // set true behind HTTPS
    maxAge: SESSION_TTL_MS,
    path: "/"
  });
}

// ---------- helpers ----------
function validateCurrency(cur) { return ["USD", "EUR", "RUB"].includes(cur); }
function validateProvider(provider) { return ["cryptobot", "platega"].includes(provider); }
function validateMethod(provider, method) {
  if (provider === "cryptobot") return method === "crypto";
  if (provider === "platega") return ["sbp", "card"].includes(method);
  return false;
}
function buildPayUrl(provider, method, invoiceId) {
  if (provider === "cryptobot") return `${CRYPTOBOT_PAY_BASE}?start=${encodeURIComponent(invoiceId)}`;
  return `${PLATEGA_PAY_BASE}?invoice=${encodeURIComponent(invoiceId)}&method=${encodeURIComponent(method)}`;
}

// ---------- deals helpers ----------
function ensureDealMessages(dealId) {
  if (!db.dealMessages[dealId]) db.dealMessages[dealId] = [];
  return db.dealMessages[dealId];
}
function dealToClient(d) {
  const buyer = getUserById(d.buyerId);
  const seller = getUserById(d.sellerId);
  return {
    id: d.id,
    title: d.title,
    note: d.note || "",
    amount: d.amount,
    currency: d.currency,
    status: d.status,
    buyerId: d.buyerId,
    sellerId: d.sellerId,
    buyerUsername: buyer ? buyer.username : "unknown",
    sellerUsername: seller ? seller.username : "unknown",
    escrow: d.escrow || { amount: 0, currency: d.currency, funded: false },
    createdAt: d.createdAt,
    updatedAt: d.updatedAt
  };
}
function getDealOr404(dealId) { return db.deals[dealId] || null; }
function assertDealAccess(req, res, deal) {
  const me = req.user;
  const isParticipant = deal.buyerId === me.id || deal.sellerId === me.id;
  const isAdmin = me.role === "admin";
  if (!isParticipant && !isAdmin) { res.status(403).json({ error: "Forbidden" }); return false; }
  return true;
}

// ---------- app ----------
const app = express();
app.disable("x-powered-by");
app.use(express.json({ limit: "1mb" }));
app.use(cookieParser());

app.get("/", (req, res) => res.sendFile(FILE_HTML));
app.get("/health", (req, res) => res.json({ ok: true, ts: now() }));
app.get("/favicon.ico", (req, res) => res.status(204).end());
app.get(/^\/(home|auth|profile|deals|admin)$/, (req, res) => res.sendFile(FILE_HTML));

// ---------- auth ----------
app.get("/api/me", (req, res) => {
  const s = getSession(req);
  if (!s) return res.status(200).json(null);
  const user = getUserById(s.userId);
  if (!user || user.isBanned) return res.status(200).json(null);
  return res.json({ id: user.id, email: user.email, username: user.username, role: user.role });
});

app.post("/api/auth/register", async (req, res) => {
  try {
    const email = String(req.body.email || "").trim();
    const username = String(req.body.username || "").trim();
    const password = String(req.body.password || "");

    if (!email.includes("@")) return res.status(400).json({ error: "Invalid email" });
    if (username.length < 3) return res.status(400).json({ error: "Username too short" });
    if (password.length < 8) return res.status(400).json({ error: "Password must be at least 8 chars" });

    if (getUserByEmail(email)) return res.status(409).json({ error: "Email already exists" });
    if (getUserByUsername(username)) return res.status(409).json({ error: "Username already exists" });

    const pw = await hashPassword(password);
    const user = { id: rid("u"), email, username, password: pw, role: "user", isBanned: false, createdAt: now() };
    db.users.push(user);
    ensureBalance(user.id);

    const token = rid("s") + crypto.randomBytes(18).toString("hex");
    db.sessions[token] = { userId: user.id, expiresAt: now() + SESSION_TTL_MS };
    persist();
    setSessionCookie(res, token);

    audit({ type: "auth.register", summary: "User registered", actorId: user.id, targetUserId: user.id, req, meta: { email } });
    res.json({ ok: true });
  } catch (e) {
    console.error(e);
    res.status(500).json({ error: "Server error" });
  }
});

app.post("/api/auth/login", async (req, res) => {
  try {
    const emailOrUsername = String(req.body.emailOrUsername || "").trim();
    const password = String(req.body.password || "");
    if (!emailOrUsername || !password) return res.status(400).json({ error: "Missing credentials" });

    const user = emailOrUsername.includes("@") ? getUserByEmail(emailOrUsername) : getUserByUsername(emailOrUsername);
    if (!user) return res.status(401).json({ error: "Invalid credentials" });
    if (user.isBanned) return res.status(403).json({ error: "User banned" });

    const ok = await verifyPassword(password, user.password);
    if (!ok) {
      audit({ type: "auth.login_failed", summary: "Bad password", actorId: user.id, targetUserId: user.id, req, meta: {} });
      return res.status(401).json({ error: "Invalid credentials" });
    }

    const token = rid("s") + crypto.randomBytes(18).toString("hex");
    db.sessions[token] = { userId: user.id, expiresAt: now() + SESSION_TTL_MS };
    persist();
    setSessionCookie(res, token);

    audit({ type: "auth.login", summary: "User logged in", actorId: user.id, targetUserId: user.id, req, meta: {} });
    res.json({ ok: true });
  } catch (e) {
    console.error(e);
    res.status(500).json({ error: "Server error" });
  }
});

app.post("/api/auth/logout", requireAuth, (req, res) => {
  const token = req.session.token;
  delete db.sessions[token];
  persist();
  res.clearCookie(SESSION_COOKIE, { path: "/" });
  audit({ type: "auth.logout", summary: "User logged out", actorId: req.user.id, targetUserId: req.user.id, req, meta: {} });
  res.json({ ok: true });
});

// ---------- security ----------
app.post("/api/security/change-password", requireAuth, async (req, res) => {
  try {
    const oldPassword = String(req.body.oldPassword || "");
    const newPassword = String(req.body.newPassword || "");
    if (newPassword.length < 8) return res.status(400).json({ error: "New password must be at least 8 chars" });

    const user = req.user;
    const ok = await verifyPassword(oldPassword, user.password);
    if (!ok) return res.status(401).json({ error: "Old password incorrect" });

    user.password = await hashPassword(newPassword);
    persist();
    audit({ type: "security.password_changed", summary: "Password changed", actorId: user.id, targetUserId: user.id, req, meta: {} });
    res.json({ ok: true });
  } catch (e) {
    console.error(e);
    res.status(500).json({ error: "Server error" });
  }
});

// ---------- logs ----------
app.get("/api/logs/me", requireAuth, (req, res) => {
  const limit = Math.max(1, Math.min(500, Number(req.query.limit || 200)));
  const items = db.audit
    .filter(x => x.targetUserId === req.user.id || x.actorId === req.user.id)
    .slice(-limit)
    .reverse();
  res.json({ items });
});

// ---------- wallet ----------
app.get("/api/wallet/balances", requireAuth, (req, res) => {
  res.json({ balances: ensureBalance(req.user.id) });
});

app.post("/api/wallet/topup/create", requireAuth, (req, res) => {
  const amount = Number(req.body.amount);
  const currency = String(req.body.currency || "USD").toUpperCase();
  const provider = String(req.body.provider || "").toLowerCase();
  const method = String(req.body.method || "").toLowerCase();

  if (!(amount > 0) || !Number.isFinite(amount)) return res.status(400).json({ error: "Invalid amount" });
  if (!validateCurrency(currency)) return res.status(400).json({ error: "Unsupported currency" });
  if (!validateProvider(provider)) return res.status(400).json({ error: "Unsupported provider" });
  if (!validateMethod(provider, method)) return res.status(400).json({ error: "Unsupported method" });

  if (provider === "platega" && method === "sbp" && currency !== "RUB") {
    return res.status(400).json({ error: "SBP works with RUB only" });
  }

  const id = rid("inv");
  const inv = {
    id,
    userId: req.user.id,
    amount: round2(amount),
    currency,
    provider,
    method,
    status: "created",
    payUrl: buildPayUrl(provider, method, id),
    createdAt: now(),
    paidAt: null
  };
  db.topups[id] = inv;
  persist();

  audit({
    type: "wallet.topup_created",
    summary: "Topup invoice created",
    actorId: req.user.id,
    targetUserId: req.user.id,
    req,
    meta: { invoiceId: id, amount: inv.amount, currency, provider, method }
  });

  res.json(inv);
});

app.get("/api/wallet/topup/status", requireAuth, (req, res) => {
  const id = String(req.query.id || "");
  const inv = db.topups[id];
  if (!inv) return res.status(404).json({ error: "Invoice not found" });
  if (inv.userId !== req.user.id && req.user.role !== "admin") return res.status(403).json({ error: "Forbidden" });
  res.json({ id: inv.id, status: inv.status });
});

// DEV helper: mark invoice paid (admin). Remove/guard in production.
app.post("/api/dev/mark-paid", requireAuth, requireAdmin, (req, res) => {
  const invoiceId = String(req.body.invoiceId || "");
  const inv = db.topups[invoiceId];
  if (!inv) return res.status(404).json({ error: "Invoice not found" });
  if (inv.status === "paid") return res.json({ ok: true });

  inv.status = "paid";
  inv.paidAt = now();

  const bal = ensureBalance(inv.userId);
  bal[inv.currency] = round2(bal[inv.currency] + inv.amount);
  persist();

  audit({
    type: "wallet.topup_paid",
    summary: "Topup paid",
    actorId: req.user.id,
    targetUserId: inv.userId,
    req,
    meta: { invoiceId: inv.id, amount: inv.amount, currency: inv.currency, provider: inv.provider, method: inv.method }
  });

  res.json({ ok: true });
});

app.post("/api/wallet/withdraw", requireAuth, (req, res) => {
  const amount = Number(req.body.amount);
  const currency = String(req.body.currency || "USD").toUpperCase();
  const destination = String(req.body.destination || "").trim();
  const note = String(req.body.note || "").trim();

  if (!(amount > 0) || !Number.isFinite(amount)) return res.status(400).json({ error: "Invalid amount" });
  if (!validateCurrency(currency)) return res.status(400).json({ error: "Unsupported currency" });
  if (!destination) return res.status(400).json({ error: "Destination required" });

  const bal = ensureBalance(req.user.id);
  if (bal[currency] < amount) return res.status(400).json({ error: "Insufficient funds" });

  bal[currency] = round2(bal[currency] - amount);

  const id = rid("wd");
  db.withdrawals[id] = { id, userId: req.user.id, amount: round2(amount), currency, destination: clampStr(destination, 120), note: clampStr(note, 160), status: "pending", createdAt: now() };
  persist();

  audit({
    type: "wallet.withdraw_requested",
    summary: "Withdraw requested (pending)",
    actorId: req.user.id,
    targetUserId: req.user.id,
    req,
    meta: { withdrawId: id, amount, currency, destination: clampStr(destination, 80) }
  });

  res.json({ ok: true, id, status: "pending" });
});

// ---------- deals ----------
app.get("/api/deals", requireAuth, (req, res) => {
  const me = req.user;
  const items = Object.values(db.deals)
    .filter(d => d.buyerId === me.id || d.sellerId === me.id || me.role === "admin")
    .sort((a,b) => (b.updatedAt || b.createdAt) - (a.updatedAt || a.createdAt))
    .slice(0, 500)
    .map(dealToClient);
  res.json({ items });
});

app.post("/api/deals", requireAuth, (req, res) => {
  const me = req.user;

  const type = String(req.body.type || "buy"); // buy/sell
  const counterparty = String(req.body.counterparty || "").trim();
  const title = String(req.body.title || "").trim();
  const currency = String(req.body.currency || "USD").toUpperCase();
  const amount = Number(req.body.amount);
  const note = String(req.body.note || "").trim();

  if (!["buy","sell"].includes(type)) return res.status(400).json({ error: "Invalid type" });
  if (!counterparty) return res.status(400).json({ error: "Counterparty required" });
  if (!title || title.length < 3) return res.status(400).json({ error: "Title too short" });
  if (!validateCurrency(currency)) return res.status(400).json({ error: "Unsupported currency" });
  if (!(amount > 0) || !Number.isFinite(amount)) return res.status(400).json({ error: "Invalid amount" });

  const other = counterparty.includes("@") ? getUserByEmail(counterparty) : getUserByUsername(counterparty);
  if (!other) return res.status(404).json({ error: "User not found" });
  if (other.isBanned) return res.status(400).json({ error: "User not available" });
  if (other.id === me.id) return res.status(400).json({ error: "Cannot create deal with yourself" });

  const buyerId = (type === "buy") ? me.id : other.id;
  const sellerId = (type === "sell") ? me.id : other.id;

  const id = rid("deal");
  const deal = {
    id,
    title: clampStr(title, 120),
    note: clampStr(note, 240),
    amount: round2(amount),
    currency,
    status: "created",
    buyerId,
    sellerId,
    escrow: { amount: 0, currency, funded: false },
    createdAt: now(),
    updatedAt: now()
  };
  db.deals[id] = deal;
  ensureDealMessages(id);
  persist();

  audit({
    type: "deal.created",
    summary: `Deal created: ${deal.title}`,
    actorId: me.id,
    targetUserId: other.id,
    req,
    meta: { dealId: id, amount: deal.amount, currency, buyerId, sellerId }
  });

  res.json({ ok: true, id });
});

app.get("/api/deals/:id", requireAuth, (req, res) => {
  const deal = getDealOr404(req.params.id);
  if (!deal) return res.status(404).json({ error: "Deal not found" });
  if (!assertDealAccess(req, res, deal)) return;
  res.json({ deal: dealToClient(deal) });
});

app.post("/api/deals/:id/fund", requireAuth, (req, res) => {
  const deal = getDealOr404(req.params.id);
  if (!deal) return res.status(404).json({ error: "Deal not found" });
  if (!assertDealAccess(req, res, deal)) return;

  if (deal.status !== "created") return res.status(400).json({ error: "Deal is not fundable" });
  if (req.user.id !== deal.buyerId && req.user.role !== "admin") return res.status(403).json({ error: "Only buyer can fund" });

  const bal = ensureBalance(deal.buyerId);
  if (bal[deal.currency] < deal.amount) return res.status(400).json({ error: "Insufficient funds in wallet" });

  bal[deal.currency] = round2(bal[deal.currency] - deal.amount);
  deal.escrow = { amount: deal.amount, currency: deal.currency, funded: true };
  deal.status = "funded";
  deal.updatedAt = now();
  persist();

  audit({
    type: "deal.funded",
    summary: "Deal funded (escrow)",
    actorId: req.user.id,
    targetUserId: deal.buyerId,
    req,
    meta: { dealId: deal.id, amount: deal.amount, currency: deal.currency }
  });

  res.json({ ok: true });
});

app.post("/api/deals/:id/mark-delivered", requireAuth, (req, res) => {
  const deal = getDealOr404(req.params.id);
  if (!deal) return res.status(404).json({ error: "Deal not found" });
  if (!assertDealAccess(req, res, deal)) return;

  if (deal.status !== "funded") return res.status(400).json({ error: "Deal is not in funded state" });
  if (req.user.id !== deal.sellerId && req.user.role !== "admin") return res.status(403).json({ error: "Only seller can mark delivered" });

  deal.status = "delivered";
  deal.updatedAt = now();
  persist();

  audit({
    type: "deal.delivered",
    summary: "Seller marked delivered",
    actorId: req.user.id,
    targetUserId: deal.sellerId,
    req,
    meta: { dealId: deal.id }
  });

  res.json({ ok: true });
});

app.post("/api/deals/:id/confirm", requireAuth, (req, res) => {
  const deal = getDealOr404(req.params.id);
  if (!deal) return res.status(404).json({ error: "Deal not found" });
  if (!assertDealAccess(req, res, deal)) return;

  if (deal.status !== "delivered") return res.status(400).json({ error: "Deal is not deliver-confirmable" });
  if (req.user.id !== deal.buyerId && req.user.role !== "admin") return res.status(403).json({ error: "Only buyer can confirm" });

  if (!deal.escrow || !deal.escrow.funded || deal.escrow.amount !== deal.amount) {
    return res.status(400).json({ error: "Escrow state invalid" });
  }

  const sellerBal = ensureBalance(deal.sellerId);
  sellerBal[deal.currency] = round2(sellerBal[deal.currency] + deal.amount);

  deal.escrow = { amount: 0, currency: deal.currency, funded: false };
  deal.status = "completed";
  deal.updatedAt = now();
  persist();

  audit({
    type: "deal.completed",
    summary: "Deal completed (escrow released)",
    actorId: req.user.id,
    targetUserId: deal.sellerId,
    req,
    meta: { dealId: deal.id, amount: deal.amount, currency: deal.currency }
  });

  res.json({ ok: true });
});

app.post("/api/deals/:id/cancel", requireAuth, (req, res) => {
  const deal = getDealOr404(req.params.id);
  if (!deal) return res.status(404).json({ error: "Deal not found" });
  if (!assertDealAccess(req, res, deal)) return;

  const isParticipant = req.user.id === deal.buyerId || req.user.id === deal.sellerId;
  const isAdmin = req.user.role === "admin";
  if (!isParticipant && !isAdmin) return res.status(403).json({ error: "Forbidden" });

  if (deal.status !== "created") return res.status(400).json({ error: "Only non-funded deals can be canceled" });

  deal.status = "canceled";
  deal.updatedAt = now();
  persist();

  audit({
    type: "deal.canceled",
    summary: "Deal canceled",
    actorId: req.user.id,
    targetUserId: (req.user.id === deal.buyerId ? deal.sellerId : deal.buyerId),
    req,
    meta: { dealId: deal.id }
  });

  res.json({ ok: true });
});

app.post("/api/deals/:id/dispute", requireAuth, (req, res) => {
  const deal = getDealOr404(req.params.id);
  if (!deal) return res.status(404).json({ error: "Deal not found" });
  if (!assertDealAccess(req, res, deal)) return;

  if (!["funded","delivered"].includes(deal.status)) return res.status(400).json({ error: "Dispute not allowed in this state" });

  deal.status = "disputed";
  deal.updatedAt = now();
  persist();

  audit({
    type: "deal.disputed",
    summary: "Dispute opened",
    actorId: req.user.id,
    targetUserId: (req.user.id === deal.buyerId ? deal.sellerId : deal.buyerId),
    req,
    meta: { dealId: deal.id }
  });

  res.json({ ok: true });
});

app.get("/api/deals/:id/messages", requireAuth, (req, res) => {
  const deal = getDealOr404(req.params.id);
  if (!deal) return res.status(404).json({ error: "Deal not found" });
  if (!assertDealAccess(req, res, deal)) return;

  const limit = Math.max(1, Math.min(500, Number(req.query.limit || 120)));
  const items = ensureDealMessages(deal.id).slice(-limit).map(m => ({
    id: m.id,
    dealId: m.dealId,
    ts: m.ts,
    userId: m.userId,
    username: (getUserById(m.userId)?.username || "user"),
    text: m.text
  }));
  res.json({ items });
});

app.post("/api/deals/:id/messages", requireAuth, (req, res) => {
  const deal = getDealOr404(req.params.id);
  if (!deal) return res.status(404).json({ error: "Deal not found" });
  if (!assertDealAccess(req, res, deal)) return;

  const text = String(req.body.text || "").trim();
  if (!text) return res.status(400).json({ error: "Message empty" });
  if (text.length > 2000) return res.status(400).json({ error: "Message too long" });

  const msg = { id: rid("msg"), dealId: deal.id, ts: now(), userId: req.user.id, text };
  ensureDealMessages(deal.id).push(msg);
  persist();

  audit({
    type: "chat.message",
    summary: "Message sent",
    actorId: req.user.id,
    targetUserId: (req.user.id === deal.buyerId ? deal.sellerId : deal.buyerId),
    req,
    meta: { dealId: deal.id, messageId: msg.id }
  });

  res.json({ ok: true, id: msg.id });
});

// ---------- admin ----------
app.get("/api/admin/users", requireAuth, requireAdmin, (req, res) => {
  const items = db.users.map(safeUser);
  res.json({ items });
});

app.get("/api/admin/users/:id", requireAuth, requireAdmin, (req, res) => {
  const id = req.params.id;
  const u = getUserById(id);
  if (!u) return res.status(404).json({ error: "User not found" });
  res.json({ user: safeUser(u), balances: ensureBalance(u.id) });
});

app.get("/api/admin/users/:id/logs", requireAuth, requireAdmin, (req, res) => {
  const id = req.params.id;
  const limit = Math.max(1, Math.min(1000, Number(req.query.limit || 200)));
  const items = db.audit.filter(x => x.targetUserId === id || x.actorId === id).slice(-limit).reverse();
  res.json({ items });
});

app.get("/api/admin/users/:id/deals", requireAuth, requireAdmin, (req, res) => {
  const id = req.params.id;
  const limit = Math.max(1, Math.min(1000, Number(req.query.limit || 200)));
  const items = Object.values(db.deals)
    .filter(d => d.buyerId === id || d.sellerId === id)
    .sort((a,b) => (b.updatedAt || b.createdAt) - (a.updatedAt || a.createdAt))
    .slice(0, limit)
    .map(dealToClient);
  res.json({ items });
});

app.post("/api/admin/users/:id/adjust-balance", requireAuth, requireAdmin, (req, res) => {
  const id = req.params.id;
  const currency = String(req.body.currency || "USD").toUpperCase();
  const delta = Number(req.body.delta);
  const reason = String(req.body.reason || "").trim();

  if (!validateCurrency(currency)) return res.status(400).json({ error: "Unsupported currency" });
  if (!Number.isFinite(delta) || delta === 0) return res.status(400).json({ error: "Invalid delta" });

  const u = getUserById(id);
  if (!u) return res.status(404).json({ error: "User not found" });

  const bal = ensureBalance(id);
  bal[currency] = round2(bal[currency] + delta);
  persist();

  audit({
    type: "admin.adjust_balance",
    summary: "Admin adjusted balance",
    actorId: req.user.id,
    targetUserId: id,
    req,
    meta: { currency, delta: round2(delta), reason: clampStr(reason, 160) }
  });

  res.json({ ok: true, balances: bal });
});

app.post("/api/admin/users/:id/ban", requireAuth, requireAdmin, (req, res) => {
  const id = req.params.id;
  const isBanned = !!req.body.isBanned;

  const u = getUserById(id);
  if (!u) return res.status(404).json({ error: "User not found" });
  if (u.id === req.user.id) return res.status(400).json({ error: "Cannot ban yourself" });

  u.isBanned = isBanned;
  persist();

  audit({
    type: "admin.ban_toggle",
    summary: isBanned ? "User banned" : "User unbanned",
    actorId: req.user.id,
    targetUserId: id,
    req,
    meta: { isBanned }
  });

  res.json({ ok: true });
});

app.post("/api/admin/users/:id/set-role", requireAuth, requireAdmin, (req, res) => {
  const id = req.params.id;
  const role = String(req.body.role || "user");
  if (!["user", "admin"].includes(role)) return res.status(400).json({ error: "Invalid role" });

  const u = getUserById(id);
  if (!u) return res.status(404).json({ error: "User not found" });

  u.role = role;
  persist();

  audit({
    type: "admin.set_role",
    summary: "Role changed",
    actorId: req.user.id,
    targetUserId: id,
    req,
    meta: { role }
  });

  res.json({ ok: true });
});

app.get("/api/admin/logs", requireAuth, requireAdmin, (req, res) => {
  const limit = Math.max(1, Math.min(1000, Number(req.query.limit || 200)));
  const items = db.audit.slice(-limit).reverse();
  res.json({ items });
});

// ---------- start ----------
bootstrapDemoAdmin().then(() => {
  app.listen(PORT, HOST, () => {
    console.log(`OnlyMarket server running on http://${HOST}:${PORT}`);
  });
});
