#!/usr/bin/env node
/**
 * OnlyMarket — MINIMAL WORKING BACKEND (CommonJS)
 * ------------------------------------------------
 * Goals:
 *  - Starts on Node 18+ with "type":"module" in package.json (use .cjs)
 *  - Does NOT delete/overwrite your existing data by default
 *  - Tolerates JSON files stored as ARRAY or OBJECT (map)
 *  - Supports legacy users format:
 *      - new: { passwordHash: "scrypt$..." } or "sha256$..."
 *      - old: { password: { salt, hash } } (pbkdf2/sha512 fallback)
 *  - Core marketplace: users, listings, orders(deals), chat, wallet, audit
 *  - Payments: CryptoBot Crypto Pay API only (create invoice + status + credit)
 *
 * ENV:
 *   PORT=3000
 *   CRYPTOPAY_TOKEN=...   // @CryptoBot -> Crypto Pay -> My Apps
 *   BASE_URL=http://your-domain:3000  // optional for redirects / logs
 *
 * RUN:
 *   node server.cjs
 *
 * NOTE:
 *  - This file is intentionally verbose and commented (easy to extend).
 */

const express = require("express");
const fs = require("fs");
const path = require("path");
const crypto = require("crypto");

let cookieParser;
try { cookieParser = require("cookie-parser"); } catch { cookieParser = null; }

let nanoid;
try { ({ nanoid } = require("nanoid")); } catch {
  nanoid = (n=12) => crypto.randomBytes(Math.ceil(n*0.75)).toString("base64url").slice(0,n);
}

const now = () => Date.now();

/* ==============================
   Paths / Directories
============================== */
const ROOT = __dirname; // ~/om/server
const DATA_DIR = path.join(ROOT, "data");
const BACKUP_DIR = path.join(DATA_DIR, "backups");
const MEDIA_DIR = path.join(DATA_DIR, "media");

// public directory: ../public (recommended) or ./public
const PUBLIC_DIR_PRIMARY = path.join(ROOT, "..", "public");
const PUBLIC_DIR_FALLBACK = path.join(ROOT, "public");
const PUBLIC_DIR = fs.existsSync(PUBLIC_DIR_PRIMARY) ? PUBLIC_DIR_PRIMARY : PUBLIC_DIR_FALLBACK;

for (const d of [DATA_DIR, BACKUP_DIR, MEDIA_DIR]) {
  if (!fs.existsSync(d)) fs.mkdirSync(d, { recursive: true });
}

/* ==============================
   Safe JSON read/write
============================== */

/**
 * Reads JSON file.
 * - If missing and fallback is provided -> creates it (ONLY when file absent).
 * - If parse error -> DOES NOT overwrite existing file, returns fallback.
 */
function readJSON(fileName, fallback) {
  const fp = path.join(DATA_DIR, fileName);
  if (!fs.existsSync(fp)) {
    if (typeof fallback !== "undefined") {
      try { fs.writeFileSync(fp, JSON.stringify(fallback, null, 2)); } catch {}
      return fallback;
    }
    return null;
  }
  const raw = fs.readFileSync(fp, "utf8");
  if (!raw || !raw.trim()) return (typeof fallback !== "undefined") ? fallback : null;
  try {
    return JSON.parse(raw);
  } catch (e) {
    console.error("readJson failed:", fileName, String(e && e.message ? e.message : e));
    return (typeof fallback !== "undefined") ? fallback : null;
  }
}

function writeJSON(fileName, obj) {
  const fp = path.join(DATA_DIR, fileName);
  const stamp = new Date().toISOString().replace(/[:.]/g, "-");
  // backup best-effort
  try {
    const bak = path.join(BACKUP_DIR, `${fileName}.${stamp}.bak`);
    fs.writeFileSync(bak, fs.readFileSync(fp));
  } catch {}
  // atomic write
  const tmp = fp + ".tmp";
  fs.writeFileSync(tmp, JSON.stringify(obj, null, 2));
  fs.renameSync(tmp, fp);
}

/* ==============================
   Shape helpers (array vs map)
============================== */

function isPlainObject(x) {
  return !!x && typeof x === "object" && !Array.isArray(x);
}

function mapFromArray(arr, key = "id") {
  const m = {};
  for (const it of (Array.isArray(arr) ? arr : [])) {
    if (!it) continue;
    const k = it[key];
    if (k) m[String(k)] = it;
  }
  return m;
}

function arrayFromMap(obj) {
  if (!isPlainObject(obj)) return [];
  return Object.values(obj);
}

/**
 * Loads dataset preserving original shape:
 * - if file contains array -> returns { shape:"array", arr, map }
 * - if file contains object -> returns { shape:"map", arr, map }
 * - if empty -> uses fallback shape from fallback argument
 */
function loadDataset(fileName, fallbackValue) {
  const data = readJSON(fileName, fallbackValue);
  if (Array.isArray(data)) {
    return { shape: "array", arr: data, map: mapFromArray(data) };
  }
  if (isPlainObject(data)) {
    return { shape: "map", arr: arrayFromMap(data), map: data };
  }
  // fallback
  if (Array.isArray(fallbackValue)) {
    return { shape: "array", arr: fallbackValue, map: mapFromArray(fallbackValue) };
  }
  if (isPlainObject(fallbackValue)) {
    return { shape: "map", arr: arrayFromMap(fallbackValue), map: fallbackValue };
  }
  return { shape: "map", arr: [], map: {} };
}

function saveDataset(fileName, ds) {
  if (!ds || !ds.shape) throw new Error("Bad dataset");
  if (ds.shape === "array") return writeJSON(fileName, Array.isArray(ds.arr) ? ds.arr : []);
  return writeJSON(fileName, isPlainObject(ds.map) ? ds.map : {});
}

/* ==============================
   Security / Passwords
============================== */

// legacy from server.fixed.js: sha256$base64(password)
function hashPwLegacy(p) {
  return "sha256$" + Buffer.from(String(p)).toString("base64");
}
function checkLegacy(p, stored) {
  return !!stored && String(stored).startsWith("sha256$") && hashPwLegacy(p) === stored;
}

// scrypt preferred (Node 18)
function hashPw(p) {
  const salt = crypto.randomBytes(16);
  const key = crypto.scryptSync(String(p), salt, 64, { N: 16384, r: 8, p: 1 });
  return "scrypt$" + salt.toString("hex") + "$" + key.toString("hex");
}
function checkPwScrypt(p, stored) {
  try {
    const parts = String(stored).split("$");
    if (parts.length !== 3) return false;
    const salt = Buffer.from(parts[1], "hex");
    const keyHex = parts[2];
    const key = crypto.scryptSync(String(p), salt, 64, { N: 16384, r: 8, p: 1 });
    return crypto.timingSafeEqual(Buffer.from(keyHex, "hex"), key);
  } catch {
    return false;
  }
}

// old users format: { password: { salt, hash } } (your current data sample)
function checkPwOldObject(p, obj) {
  if (!obj || !obj.salt || !obj.hash) return false;
  const saltHex = String(obj.salt);
  const hashHex = String(obj.hash);
  const saltBuf = Buffer.from(saltHex, "hex");

  // Try pbkdf2 variants first (most likely)
  const tryPbkdf2 = (iters) => {
    try {
      const dkLen = Math.max(16, Math.floor(hashHex.length / 2));
      const dk = crypto.pbkdf2Sync(String(p), saltBuf, iters, dkLen, "sha512");
      return crypto.timingSafeEqual(Buffer.from(hashHex, "hex"), dk);
    } catch { return false; }
  };

  if (tryPbkdf2(100000)) return true;
  if (tryPbkdf2(50000)) return true;
  if (tryPbkdf2(20000)) return true;
  if (tryPbkdf2(10000)) return true;

  // Fallback: sha512(salt+password) or sha512(password+salt)
  const h1 = crypto.createHash("sha512").update(Buffer.concat([saltBuf, Buffer.from(String(p))])).digest("hex");
  if (h1 === hashHex) return true;
  const h2 = crypto.createHash("sha512").update(Buffer.concat([Buffer.from(String(p)), saltBuf])).digest("hex");
  if (h2 === hashHex) return true;

  return false;
}

function checkPwAny(p, stored) {
  if (!stored) return false;

  // scrypt$...
  if (String(stored).startsWith("scrypt$")) return checkPwScrypt(p, stored);

  // sha256$...
  if (String(stored).startsWith("sha256$")) return checkLegacy(p, stored);

  // object? (old)
  if (typeof stored === "object") return checkPwOldObject(p, stored);

  return false;
}

/* ==============================
   Normalization helpers
============================== */

function normalizeUser(u) {
  if (!u || typeof u !== "object") return null;

  // Old schema (your sample):
  // { id, email, username, password:{salt,hash}, role, isBanned }
  // New schema:
  // { id, email, nickname, passwordHash, roles, status }
  const id = u.id ? String(u.id) : ("u_" + nanoid(10));

  const email = u.email ? String(u.email) : "";
  const nickname = (u.nickname || u.username || "").toString().trim() || email || id;

  const roles = Array.isArray(u.roles) ? u.roles.slice() :
    (u.role ? [String(u.role)] : ["user"]);

  // status
  let status = u.status ? String(u.status) : "active";
  if (u.isBanned === true) status = "banned";
  if (status !== "active" && status !== "banned") status = "active";

  // passwordHash: prefer u.passwordHash, else u.password legacy object
  const passwordHash =
    u.passwordHash ? u.passwordHash :
    (u.password ? u.password : null);

  return {
    ...u,
    id,
    email,
    nickname,
    roles,
    status,
    passwordHash, // may be string or {salt,hash}
    createdAt: Number(u.createdAt || now()),
    updatedAt: Number(u.updatedAt || u.createdAt || now()),
  };
}

function userPublic(u) {
  const nu = normalizeUser(u);
  if (!nu) return null;
  return {
    id: nu.id,
    nickname: nu.nickname,
    roles: (nu.roles || []).includes("admin") ? ["admin"] : [],
    status: nu.status,
    createdAt: nu.createdAt,
  };
}

function isAdmin(u) {
  const nu = normalizeUser(u);
  if (!nu) return false;
  const roles = nu.roles || [];
  return roles.includes("admin") || roles.includes("support");
}

/* ==============================
   Audit (logs)
============================== */

function auditPush(entry) {
  const ds = loadDataset("audit.json", []);
  const arr = ds.arr || [];
  arr.push({
    id: "a_" + nanoid(10),
    ts: now(),
    ...entry,
  });
  // keep last 50k
  if (arr.length > 50000) arr.splice(0, arr.length - 50000);
  ds.arr = arr;
  ds.map = mapFromArray(arr);
  ds.shape = "array";
  saveDataset("audit.json", ds);
}

function auditAction(req, action, targetType, targetId, meta = {}) {
  const actor = req.user ? normalizeUser(req.user) : null;
  auditPush({
    actorId: actor ? actor.id : null,
    actorNick: actor ? actor.nickname : null,
    actorRoles: actor ? actor.roles : [],
    action: String(action),
    targetType: targetType ? String(targetType) : null,
    targetId: targetId ? String(targetId) : null,
    ip: req.ip,
    ua: (req.headers["user-agent"] || "").slice(0, 200),
    meta,
  });
}

/* ==============================
   Sessions / Auth middleware
============================== */

function sessionsRead() { return readJSON("sessions.json", {}); }
function sessionsWrite(o) { writeJSON("sessions.json", o || {}); }

function createSession(userId) {
  const token = "s_" + nanoid(32);
  const sessions = sessionsRead();
  sessions[token] = {
    id: token,
    userId: String(userId),
    createdAt: now(),
    expiresAt: now() + 30 * 24 * 3600 * 1000, // 30 days
  };
  sessionsWrite(sessions);
  return token;
}

function deleteSession(token) {
  if (!token) return;
  const sessions = sessionsRead();
  if (sessions[token]) {
    delete sessions[token];
    sessionsWrite(sessions);
  }
}

function loadUsersDS() {
  // users.json in your folder currently can be ARRAY (sample) or MAP
  return loadDataset("users.json", []);
}

function findUserByEmail(usersArr, email) {
  const e = String(email || "").trim().toLowerCase();
  return (usersArr || []).map(normalizeUser).find(u => (u.email || "").toLowerCase() === e) || null;
}

function findUserById(usersMap, id) {
  const u = usersMap[String(id)];
  return u ? normalizeUser(u) : null;
}

function writeUsersDS(ds) {
  // Important: preserve shape (array vs map)
  // But ensure stored values include normalized fields.
  if (ds.shape === "array") {
    ds.arr = (ds.arr || []).map(normalizeUser).filter(Boolean);
    ds.map = mapFromArray(ds.arr);
  } else {
    const out = {};
    for (const [_, u] of Object.entries(ds.map || {})) {
      const nu = normalizeUser(u);
      if (nu) out[String(nu.id)] = nu;
    }
    ds.map = out;
    ds.arr = arrayFromMap(out);
  }
  saveDataset("users.json", ds);
}

function authMiddleware(req, res, next) {
  const header = String(req.headers.authorization || "");
  const bearer = header.startsWith("Bearer ") ? header.slice(7).trim() : "";
  const token = (req.cookies && req.cookies.token) || bearer || "";

  if (!token) return next();

  const sessions = sessionsRead();
  const s = sessions[token];
  if (!s || Number(s.expiresAt || 0) < now()) return next();

  const usersDS = loadUsersDS();
  const u = findUserById(usersDS.map, s.userId);
  if (!u || u.status === "banned") return next();

  req.user = u;
  req.session = s;
  req.token = token;
  return next();
}

function requireAuth(req, res, next) {
  if (!req.user) return res.status(401).json({ error: "UNAUTH" });
  next();
}
function requireAdmin(req, res, next) {
  if (!req.user) return res.status(401).json({ error: "UNAUTH" });
  if (!isAdmin(req.user)) return res.status(403).json({ error: "FORBIDDEN" });
  next();
}

/* ==============================
   Wallet / balances
============================== */

function balancesReadDS() {
  return loadDataset("balances.json", {});
}
function balancesWriteDS(ds) {
  // balances are usually map by userId -> { available, hold, history[] }
  if (ds.shape === "array") {
    // array of { userId, available, hold, history }
    ds.arr = Array.isArray(ds.arr) ? ds.arr : [];
    ds.map = {};
    for (const it of ds.arr) {
      if (!it) continue;
      const uid = it.userId || it.id;
      if (!uid) continue;
      ds.map[String(uid)] = it;
    }
    ds.shape = "map"; // normalize to map
  } else {
    ds.map = isPlainObject(ds.map) ? ds.map : {};
  }
  writeJSON("balances.json", ds.map);
}

function getBalance(userId) {
  const ds = balancesReadDS();
  const b = ds.map[String(userId)] || { available: 0, hold: 0, history: [] };
  b.available = Number(b.available || 0);
  b.hold = Number(b.hold || 0);
  b.history = Array.isArray(b.history) ? b.history : [];
  return { ds, b };
}

function putBalance(ds, userId, b) {
  ds.map[String(userId)] = b;
  balancesWriteDS(ds);
}

/* ==============================
   Listings
============================== */

function listingsReadDS() {
  // can be {} or []
  return loadDataset("listings.json", {});
}
function listingsWriteDS(ds) {
  if (ds.shape === "array") {
    ds.arr = (ds.arr || []).filter(Boolean);
    ds.map = mapFromArray(ds.arr);
    saveDataset("listings.json", ds);
  } else {
    ds.map = ds.map || {};
    saveDataset("listings.json", ds);
  }
}
function listingPublic(l) {
  if (!l) return null;
  return {
    id: l.id,
    title: l.title,
    description: l.description,
    price: Number(l.price || 0),
    currency: l.currency || "RUB",
    categoryId: l.categoryId || null,
    sellerId: l.sellerId,
    status: l.status || "active",
    createdAt: l.createdAt,
    updatedAt: l.updatedAt,
    images: Array.isArray(l.images) ? l.images : [],
  };
}

/* ==============================
   Orders / Deals
============================== */

function ordersReadDS() {
  return loadDataset("orders.json", {});
}
function ordersWriteDS(ds) {
  if (ds.shape === "array") {
    ds.arr = (ds.arr || []).filter(Boolean);
    ds.map = mapFromArray(ds.arr);
    saveDataset("orders.json", ds);
  } else {
    ds.map = ds.map || {};
    saveDataset("orders.json", ds);
  }
}
function orderRoom(orderId) { return "order:" + String(orderId); }

function orderPublicFor(u, o) {
  // For buyer/seller/admin
  const me = u ? normalizeUser(u) : null;
  const isParticipant = me && (String(o.buyerId) === me.id || String(o.sellerId) === me.id);
  const admin = me && isAdmin(me);

  if (!admin && !isParticipant) return null;

  return {
    id: o.id,
    listingId: o.listingId,
    title: o.title,
    price: Number(o.price || 0),
    currency: o.currency || "RUB",
    buyerId: o.buyerId,
    sellerId: o.sellerId,
    status: o.status, // created, paid(escrow), delivered, completed, disputed, canceled
    createdAt: o.createdAt,
    updatedAt: o.updatedAt,
    deliveredAt: o.deliveredAt || null,
    completedAt: o.completedAt || null,
  };
}

/* ==============================
   Chat (messages)
============================== */

function messagesReadDS() {
  // messages.json can be array or map; we normalize to array
  return loadDataset("messages.json", []);
}
function messagesWriteDS(ds) {
  ds.shape = "array";
  ds.arr = Array.isArray(ds.arr) ? ds.arr : [];
  // cap to last 200k (keep disk sane)
  if (ds.arr.length > 200000) ds.arr.splice(0, ds.arr.length - 200000);
  saveDataset("messages.json", ds);
}

function canAccessRoom(user, room) {
  const u = normalizeUser(user);
  if (!u) return false;
  if (isAdmin(u)) return true;

  // order chat: only buyer/seller
  if (String(room).startsWith("order:")) {
    const orderId = String(room).slice("order:".length);
    const ordersDS = ordersReadDS();
    const o = ordersDS.map[orderId] || null;
    if (!o) return false;
    return String(o.buyerId) === u.id || String(o.sellerId) === u.id;
  }
  return false;
}

/* ==============================
   CryptoBot (Crypto Pay API)
============================== */

const CRYPTOPAY_TOKEN = process.env.CRYPTOPAY_TOKEN || process.env.CRYPTOPAY_API_TOKEN || "470975:AA3MglvYwqXBSMTaMbeJQ5ZlfJHmlaFZ0Gx";
function cryptoHeaders() {
  return {
    "Content-Type": "application/json",
    "Crypto-Pay-API-Token": CRYPTOPAY_TOKEN
  };
}

async function ensureFetch() {
  if (typeof fetch === "function") return fetch;
  // Node <18 fallback
  const mod = await import("node-fetch");
  return mod.default || mod;
}

function topupsReadDS() { return loadDataset("topups.json", {}); }
function topupsWriteDS(ds) { saveDataset("topups.json", ds); }

/* ==============================
   Express App
============================== */

const app = express();
app.set("trust proxy", true);

app.use(express.json({ limit: "10mb" }));
app.use(express.urlencoded({ extended: true, limit: "10mb" }));
if (cookieParser) app.use(cookieParser());

// Attach auth
app.use(authMiddleware);

// Static
if (fs.existsSync(PUBLIC_DIR)) {
  app.use(express.static(PUBLIC_DIR, { extensions: ["html"] }));
}

// Health
app.get("/api/health", (req, res) => {
  res.json({ ok: true, name: "OnlyMarket", time: now() });
});

/* ==============================
   AUTH
============================== */

app.post("/api/auth/register", (req, res) => {
  const { email, password, nickname } = req.body || {};
  const em = String(email || "").trim();
  const pw = String(password || "");
  const nn = String(nickname || "").trim();

  if (!em || !pw || nn.length < 2) return res.status(400).json({ error: "VALIDATION" });

  const usersDS = loadUsersDS();
  const usersArr = usersDS.arr.map(normalizeUser);

  if (findUserByEmail(usersArr, em)) return res.status(400).json({ error: "EMAIL_EXISTS" });
  if (usersArr.some(u => String(u.nickname || "").toLowerCase() === nn.toLowerCase()))
    return res.status(400).json({ error: "NICK_EXISTS" });

  const id = "u_" + nanoid(18);
  const user = normalizeUser({
    id,
    email: em,
    nickname: nn,
    roles: ["user"],
    status: "active",
    passwordHash: hashPw(pw),
    createdAt: now(),
    updatedAt: now(),
  });

  if (usersDS.shape === "array") {
    usersDS.arr.push(user);
    usersDS.map[user.id] = user;
  } else {
    usersDS.map[user.id] = user;
    usersDS.arr.push(user);
  }

  writeUsersDS(usersDS);

  // create empty balance
  const { ds: bds, b } = getBalance(user.id);
  if (!bds.map[user.id]) {
    bds.map[user.id] = { available: 0, hold: 0, history: [] };
    balancesWriteDS(bds);
  }

  const token = createSession(user.id);
  res.cookie("token", token, { httpOnly: false, sameSite: "lax" });

  auditAction(req, "auth.register", "user", user.id, { email: user.email });
  res.json({ ok: true, user: userPublic(user), token });
});

app.post("/api/auth/login", (req, res) => {
  const { email, password } = req.body || {};
  const em = String(email || "").trim();
  const pw = String(password || "");
  if (!em || !pw) return res.status(400).json({ error: "VALIDATION" });

  const usersDS = loadUsersDS();
  const usersArr = usersDS.arr.map(normalizeUser);
  const u = findUserByEmail(usersArr, em);
  if (!u) return res.status(400).json({ error: "BAD_CREDENTIALS" });
  if (u.status === "banned") return res.status(403).json({ error: "BANNED" });

  if (!checkPwAny(pw, u.passwordHash)) return res.status(400).json({ error: "BAD_CREDENTIALS" });

  const token = createSession(u.id);
  res.cookie("token", token, { httpOnly: false, sameSite: "lax" });

  auditAction(req, "auth.login", "user", u.id, {});
  res.json({ ok: true, user: userPublic(u), token });
});

app.post("/api/auth/logout", requireAuth, (req, res) => {
  deleteSession(req.token);
  res.clearCookie("token");
  auditAction(req, "auth.logout", "user", req.user.id, {});
  res.json({ ok: true });
});

app.get("/api/me", (req, res) => {
  if (!req.user) return res.json({ user: null });
  const u = normalizeUser(req.user);
  res.json({ user: { ...userPublic(u), email: u.email, roles: u.roles } });
});

app.post("/api/auth/change-password", requireAuth, (req, res) => {
  const { oldPassword, newPassword } = req.body || {};
  const oldPw = String(oldPassword || "");
  const newPw = String(newPassword || "");
  if (newPw.length < 6) return res.status(400).json({ error: "WEAK_PASSWORD" });

  const usersDS = loadUsersDS();
  const u = findUserById(usersDS.map, req.user.id);
  if (!u) return res.status(404).json({ error: "NO_USER" });

  if (u.passwordHash && !checkPwAny(oldPw, u.passwordHash))
    return res.status(400).json({ error: "BAD_OLD_PASSWORD" });

  u.passwordHash = hashPw(newPw);
  u.updatedAt = now();

  usersDS.map[u.id] = u;
  if (usersDS.shape === "array") {
    const idx = usersDS.arr.findIndex(x => String(x.id) === u.id);
    if (idx !== -1) usersDS.arr[idx] = u;
    else usersDS.arr.push(u);
  }
  writeUsersDS(usersDS);

  auditAction(req, "auth.change_password", "user", u.id, {});
  res.json({ ok: true });
});

/* ==============================
   USERS (public / lookup)
============================== */

app.get("/api/users/:id/public", (req, res) => {
  const usersDS = loadUsersDS();
  const u = findUserById(usersDS.map, req.params.id);
  if (!u) return res.status(404).json({ error: "NOT_FOUND" });
  res.json({ user: userPublic(u) });
});

app.get("/api/users/lookup", (req, res) => {
  const ids = String(req.query.ids || "")
    .split(",")
    .map(s => s.trim())
    .filter(Boolean)
    .slice(0, 200);

  const usersDS = loadUsersDS();
  const out = ids.map(id => {
    const u = usersDS.map[id];
    return u ? userPublic(u) : { id, nickname: id, roles: [], status: "unknown", createdAt: null };
  });
  res.json(out);
});

/* ==============================
   ADMIN: user overview + audit
============================== */

app.get("/api/admin/users", requireAdmin, (req, res) => {
  const q = String(req.query.q || "").trim().toLowerCase();
  const limit = Math.min(200, Math.max(1, Number(req.query.limit || 50)));

  const usersDS = loadUsersDS();
  let arr = usersDS.arr.map(normalizeUser).filter(Boolean);

  if (q) {
    arr = arr.filter(u =>
      (u.email || "").toLowerCase().includes(q) ||
      (u.nickname || "").toLowerCase().includes(q) ||
      (u.id || "").toLowerCase().includes(q)
    );
  }
  arr = arr
    .sort((a,b)=> (b.createdAt||0)-(a.createdAt||0))
    .slice(0, limit)
    .map(u => ({ ...userPublic(u), email: u.email, roles: u.roles }));

  res.json({ users: arr });
});

app.get("/api/admin/users/:id/overview", requireAdmin, (req, res) => {
  const userId = String(req.params.id);
  const usersDS = loadUsersDS();
  const u = findUserById(usersDS.map, userId);
  if (!u) return res.status(404).json({ error: "NOT_FOUND" });

  const { b } = getBalance(userId);

  const history = Array.isArray(b.history) ? b.history.slice(-200).reverse() : [];

  const ordersDS = ordersReadDS();
  const allOrders = Object.values(ordersDS.map || {}).filter(Boolean);
  const asBuyer = allOrders.filter(o => String(o.buyerId) === userId);
  const asSeller = allOrders.filter(o => String(o.sellerId) === userId);

  const auditDS = loadDataset("audit.json", []);
  const aud = (auditDS.arr || [])
    .filter(x => String(x.actorId || "") === userId || String(x.targetId || "") === userId)
    .slice(-300)
    .reverse();

  res.json({
    user: { ...userPublic(u), email: u.email, roles: u.roles },
    balance: { available: b.available, hold: b.hold },
    walletHistory: history,
    orders: {
      buyerCount: asBuyer.length,
      sellerCount: asSeller.length,
      lastBuyer: asBuyer.slice(-20).reverse(),
      lastSeller: asSeller.slice(-20).reverse(),
    },
    audit: aud,
  });
});

/* ==============================
   CATEGORIES
============================== */

app.get("/api/categories", (req, res) => {
  const cats = readJSON("categories.json", []);
  res.json(Array.isArray(cats) ? cats : []);
});

/* ==============================
   LISTINGS
============================== */

app.get("/api/listings", (req, res) => {
  const q = String(req.query.q || "").trim().toLowerCase();
  const categoryId = String(req.query.categoryId || "").trim();
  const status = String(req.query.status || "active").trim();

  const ds = listingsReadDS();
  let arr = ds.shape === "array" ? (ds.arr || []) : Object.values(ds.map || {});
  arr = arr.filter(Boolean);

  if (status) arr = arr.filter(l => String(l.status || "active") === status);
  if (categoryId) arr = arr.filter(l => String(l.categoryId || "") === categoryId);
  if (q) arr = arr.filter(l =>
    String(l.title || "").toLowerCase().includes(q) ||
    String(l.description || "").toLowerCase().includes(q)
  );

  const me = req.user ? normalizeUser(req.user) : null;
  if (!me || !isAdmin(me)) arr = arr.filter(l => String(l.status || "active") !== "disabled");

  arr.sort((a,b)=> Number(b.createdAt||0)-Number(a.createdAt||0));
  res.json({ listings: arr.slice(0, 200).map(listingPublic) });
});

app.post("/api/listings", requireAuth, (req, res) => {
  const me = normalizeUser(req.user);
  const { title, description, price, currency = "RUB", categoryId = null, images = [] } = req.body || {};
  const t = String(title || "").trim();
  const d = String(description || "").trim();
  const p = Number(price || 0);

  if (t.length < 2 || d.length < 2 || !(p > 0)) return res.status(400).json({ error: "VALIDATION" });

  const ds = listingsReadDS();
  const id = "l_" + nanoid(12);
  const item = {
    id,
    title: t,
    description: d,
    price: +p.toFixed(2),
    currency: String(currency || "RUB"),
    categoryId: categoryId ? String(categoryId) : null,
    sellerId: me.id,
    status: "active",
    images: Array.isArray(images) ? images.slice(0, 8) : [],
    createdAt: now(),
    updatedAt: now(),
  };

  if (ds.shape === "array") {
    ds.arr.push(item);
    ds.map[item.id] = item;
  } else {
    ds.map[item.id] = item;
  }
  listingsWriteDS(ds);

  auditAction(req, "listing.create", "listing", item.id, { price: item.price, currency: item.currency });
  res.json({ ok: true, listing: listingPublic(item) });
});

/* ==============================
   WALLET
============================== */

app.get("/api/wallet", requireAuth, (req, res) => {
  const u = normalizeUser(req.user);
  const { b } = getBalance(u.id);
  res.json({
    balance: { available: b.available, hold: b.hold },
    history: (Array.isArray(b.history) ? b.history.slice(-100).reverse() : []),
  });
});

/* ==============================
   ORDERS / DEALS (escrow minimum)
============================== */

app.post("/api/orders/create", requireAuth, (req, res) => {
  const me = normalizeUser(req.user);
  const { listingId } = req.body || {};
  const lid = String(listingId || "");
  if (!lid) return res.status(400).json({ error: "VALIDATION" });

  const lds = listingsReadDS();
  const l = lds.map[lid] || null;
  if (!l) return res.status(404).json({ error: "LISTING_NOT_FOUND" });
  if (String(l.status || "active") !== "active") return res.status(400).json({ error: "LISTING_INACTIVE" });
  if (String(l.sellerId) === me.id) return res.status(400).json({ error: "CANT_BUY_OWN" });

  const price = Number(l.price || 0);
  if (!(price > 0)) return res.status(400).json({ error: "BAD_PRICE" });

  const { ds: bds, b } = getBalance(me.id);
  if (b.available < price) return res.status(400).json({ error: "INSUFFICIENT_BALANCE" });

  b.available -= price;
  b.hold += price;
  b.history.push({ id: "h_" + nanoid(10), type: "escrow_hold", amount: -price, listingId: lid, ts: now() });
  putBalance(bds, me.id, b);

  const ods = ordersReadDS();
  const id = "o_" + nanoid(12);

  const o = {
    id,
    listingId: lid,
    title: String(l.title || "").slice(0, 160),
    price: +price.toFixed(2),
    currency: l.currency || "RUB",
    buyerId: me.id,
    sellerId: String(l.sellerId),
    status: "paid",
    createdAt: now(),
    updatedAt: now(),
  };

  if (ods.shape === "array") {
    ods.arr.push(o); ods.map[o.id] = o;
  } else {
    ods.map[o.id] = o;
  }
  ordersWriteDS(ods);

  const mds = messagesReadDS();
  mds.arr.push({
    id: "m_" + nanoid(12),
    room: orderRoom(o.id),
    senderId: null,
    text: "Системное: сделка создана и средства удержаны в escrow.",
    ts: now(),
    type: "system",
  });
  messagesWriteDS(mds);

  auditAction(req, "order.create", "order", o.id, { listingId: lid, price });
  res.json({ ok: true, order: orderPublicFor(me, o), room: orderRoom(o.id) });
});

/* ==============================
   CHAT
============================== */

app.get("/api/chat/room", requireAuth, (req, res) => {
  const room = String(req.query.room || "").trim();
  if (!room) return res.status(400).json({ error: "VALIDATION" });
  if (!canAccessRoom(req.user, room)) return res.status(403).json({ error: "FORBIDDEN" });

  const ds = messagesReadDS();
  const msgs = (ds.arr || []).filter(m => String(m.room) === room).slice(-200);
  res.json({ room, messages: msgs });
});

app.post("/api/chat/send", requireAuth, (req, res) => {
  const room = String((req.body||{}).room || "").trim();
  const text = String((req.body||{}).text || "").trim();
  if (!room || !text) return res.status(400).json({ error: "VALIDATION" });
  if (text.length > 5000) return res.status(400).json({ error: "TOO_LONG" });
  if (!canAccessRoom(req.user, room)) return res.status(403).json({ error: "FORBIDDEN" });

  const me = normalizeUser(req.user);
  const ds = messagesReadDS();
  const msg = {
    id: "m_" + nanoid(12),
    room,
    senderId: me.id,
    text,
    ts: now(),
    type: "text",
  };
  ds.arr.push(msg);
  messagesWriteDS(ds);

  auditAction(req, "chat.send", "room", room, { len: text.length });
  res.json({ ok: true, message: msg });
});

/* ==============================
   CRYPTOBOT TOPUPS
============================== */

app.post("/api/pay/cryptobot/create", requireAuth, async (req, res) => {
  try {
    if (!CRYPTOPAY_TOKEN) return res.status(400).json({ error: "CRYPTOBOT_NOT_CONFIGURED" });

    const { amount, fiat = "RUB", accepted_assets = "USDT,TON,BTC,ETH" } = req.body || {};
    const amt = Number(amount || 0);
    if (!Number.isFinite(amt) || amt <= 0) return res.status(400).json({ error: "VALIDATION" });

    const payload = {
      currency_type: "fiat",
      fiat: String(fiat || "RUB"),
      amount: String(amt),
      accepted_assets: String(accepted_assets || "USDT,TON"),
      description: "Пополнение баланса OnlyMarket",
      allow_comments: false,
      allow_anonymous: true,
      expires_in: 600,
    };

    const _fetch = await ensureFetch();
    const r = await _fetch("https://pay.crypt.bot/api/createInvoice", {
      method: "POST",
      headers: cryptoHeaders(),
      body: JSON.stringify(payload),
    });
    const j = await r.json().catch(() => null);
    if (!j || !j.ok) throw new Error((j && j.error) || "cryptobot error");

    const inv = j.result;
    const invoiceId = "cb_" + inv.invoice_id;
    const payUrl = inv.bot_invoice_url;

    const topups = topupsReadDS();
    const u = normalizeUser(req.user);

    const rec = {
      id: invoiceId,
      provider: "CRYPTOBOT",
      userId: u.id,
      amount: amt,
      currency: String(fiat || "RUB"),
      status: inv.status || "active",
      credited: false,
      createdAt: now(),
      updatedAt: now(),
    };

    if (topups.shape === "array") {
      topups.arr.push(rec); topups.map[rec.id] = rec;
    } else {
      topups.map[rec.id] = rec;
    }
    topupsWriteDS(topups);

    auditAction(req, "wallet.topup_create", "topup", invoiceId, { amount: amt, fiat });
    res.json({ ok: true, invoiceId, payUrl });
  } catch (e) {
    console.error("cryptobot/create fail", e);
    res.status(500).json({ error: "REQUEST_FAIL" });
  }
});

app.get("/api/pay/cryptobot/status", requireAuth, async (req, res) => {
  try {
    if (!CRYPTOPAY_TOKEN) return res.json({ status: "pending", error: "CRYPTOBOT_NOT_CONFIGURED" });

    const invoiceId = String(req.query.invoiceId || "").trim();
    if (!invoiceId) return res.status(400).json({ error: "VALIDATION" });

    const topups = topupsReadDS();
    const tp = topups.map[invoiceId] || null;
    if (!tp) return res.status(404).json({ error: "NOT_FOUND" });

    const me = normalizeUser(req.user);
    if (!isAdmin(me) && String(tp.userId) !== me.id) return res.status(403).json({ error: "FORBIDDEN" });

    const invNum = invoiceId.replace(/^cb_/, "");
    const _fetch = await ensureFetch();
    const r = await _fetch("https://pay.crypt.bot/api/getInvoices?invoice_ids=" + encodeURIComponent(invNum), {
      headers: { "Crypto-Pay-API-Token": CRYPTOPAY_TOKEN }
    });
    const j = await r.json().catch(() => null);
    if (!j || !j.ok) throw new Error((j && j.error) || "getInvoices failed");

    const inv = (j.result || [])[0];
    if (!inv) return res.json({ status: "pending", rawStatus: "not_found" });

    const paid = inv.status === "paid";

    if (paid && !tp.credited) {
      const { ds: bds, b } = getBalance(tp.userId);
      const add = +Number(tp.amount || 0);

      b.available = +(Number(b.available || 0) + add).toFixed(2);
      b.history.push({
        id: "h_" + nanoid(10),
        type: "deposit_cryptobot",
        amount: add,
        currency: tp.currency || "RUB",
        provider: "CryptoBot",
        invoiceId,
        ts: now(),
      });

      putBalance(bds, tp.userId, b);

      tp.status = "paid";
      tp.credited = true;
      tp.paidAt = now();
      tp.updatedAt = now();

      topups.map[invoiceId] = tp;
      if (topups.shape === "array") {
        const idx = topups.arr.findIndex(x => String(x.id) === invoiceId);
        if (idx !== -1) topups.arr[idx] = tp;
      }
      topupsWriteDS(topups);

      auditPush({
        actorId: null,
        actorNick: "system",
        actorRoles: ["system"],
        action: "wallet.topup_credited",
        targetType: "user",
        targetId: tp.userId,
        meta: { invoiceId, amount: add, currency: tp.currency }
      });
    }

    res.json({ status: paid ? "paid" : "pending", rawStatus: inv.status });
  } catch (e) {
    console.error("cryptobot/status fail", e);
    res.status(500).json({ error: "REQUEST_FAIL" });
  }
});

/* ==============================
   Root fallback (SPA)
============================== */
app.get("/", (req, res) => {
  const indexHtml = path.join(PUBLIC_DIR, "index.html");
  if (fs.existsSync(indexHtml)) return res.sendFile(indexHtml);
  res.type("text").send("OnlyMarket backend is running. Put your frontend into /public and refresh.");
});

/* ==============================
   Start server
============================== */
const PORT = Number(process.env.PORT || 3000);
app.listen(PORT, "0.0.0.0", () => {
  console.log("OnlyMarket minimal server running on http://0.0.0.0:" + PORT);
  if (!CRYPTOPAY_TOKEN) console.log("⚠️ CRYPTOPAY_TOKEN is not set (CryptoBot topups disabled).");
});
